#pragma once

/*
* 운영 agent 
* 
* - 운영 agent는 안정적인 오픈소스 기술
* 
* 
* 기존 logging agent
* 
* - 장점
*	- agent는 fluentd를 사용하여 로그를 수집할 수 있다. 
* 
* 
* 
*/

/*
* [blackboard]
* 
* - 행동트리의 뇌, key/value 저장공간
* 
* - 노드에서 블랙보드로 접근하려면 포트를 열어야한다.
* - 트리설계단계에서 노드와 블랙보드 포트를 연결할 수 있다. 
* 
* - 플레이어의 말에 따라 다른 대답을 하는 npc
*	- 
*/

/*
* 
* - pre, post conditions 
* 
* - xml 트리 설계 단계에서 노드의 실행 전후에 조건을 추가할 수 있습니다. 
* 
* - precondition
*	- 조건을 통해서 행위를 skip한다. 
*	- _skipIf, _failureIf, _successIf, .._while 
* 
* - postcondition
*	- _onSuccess, _onFailure, _post, ..
* 
* [옵저버]
* - 트리의 실행 상태를 파악. 
* - 
* 
*/

/*
* - BT센서, NDC, 
* 
* - ZERO MQ,
* 
* - LOCK
* 
* - Memory 루키스 . 
* 
* - 
*/

/*
*  [화요일]
* 
* - 이득우의 게임수학
* 
* 
*/

/*
* - git clone 시 recursive 옵션
*	- clone 시 해당 저장소에 포함된 모든 서브모듈도 함께 클론하도록하는 기능이다.
*	- cf : git 저장소 안에 다른 git 저장소를 포함시켜 관리하는 기능.. 대규모프로젝트에서 라이브러리나 의존성을 관리할 때 유용하다.
* 
* - bt 사용 설치 예제부분에서 conan이 나온다.
*	- conan과 vcpkg 동일하게 c++ 패키지 매니저이다.
*		- conan과 cmake 궁합이 잘 맞다고하는데 자세한 것은 더 찾아보자.. 
* 
* - 
*/

/*
* 
* ./ vs ../ 
* 
* 둘다 상대경로를 지정할 수 있다. 
* 
* - ./file.txt : 현재 디렉토리에 있는 file.txt
* 
* - ../file.txt : 부모 디렉토리에 있는 file.txt 
* 
* 
* 
*/

/*
* 듀얼 cpu
*/

/*
* - 3D에서 이동처리를 제대로 하려면 충돌처리를 해야한다. 
* - 하복이나 피직스??
* - 테스트 시 클럭을 잰다고하네.. 
* - 
*/

/*
* vector, yaw 해당 부분 더 학습이 필요함. 
* 
* - 서버하는 사람들은 기하학쪽을 잘 모름
* - 클라는 네트워크를 잘 모름 
* - 스프라인 직선 ?? 
* - 샘플링한다
* - 서버에서 레이체크
* -  보간 ? .. 
* - 정지상태에서 속도벡터만큼 이동 시도 => 충돌감지 => 미끄러짐 벡터를 구해서 새로운 속도 벡터로 이동 시도 
		- 서버 플레이어 이동은 타원형으로 충돌처리 됌 

   - 로켓탄의 충돌처리가 궁금하네 .. 
   - 
*/


/*
* [기본적인 이동처리 전략]
* 
* - 이동 시작
*	- 클라이언트가 패킷을 보냄
* 
* - 서버에서 패킷 수신
*	- 브로드 캐스팅
*	- 서버측 층돌엔진에서 이동 시작
*	- 이벤트 드리븐 ??
*	- KD Tree ?
*		- KD Tree 픽킹처리할 때 좋다 ?? 픽킹 ?? 
* - 
*/

/*
* 충돌체 처리 
* 
* - 투사체일 경우
*	- client, server 모두 OnShoot, OnHit가 작동한다. 
*	- 클라이언트는 발사 시 서버로 패킷을 전송함, 클라가 실제로 물체를 맞쳤다고해도 폭발처리를하지않고 서버에서 충돌했다고 판정 시 스플래쉬나
* 주변 폭발처리를 함 
*	- 클라에서 스플래쉬를 처리를 먼저했다고 했을 시, 중간에 네트워크 연결이 끊어지게된다면 다음 보정처리가 힘들다. 
*	- 
* 
* - 로켓탄이 터졌을 때 
*	- 이벤트 드리븐이라서 싱글스레드를 이용함 왜 ?? 
*/

/*
* [네이글 알고리즘 사용 불가]
* 
* - 네이글 알고리즘을 wasd에서 사용 불가능한 이유는, 실시간 통신에서 지연성 때문이있다 
* 그렇지만 사용할 이유는 패킷을 모아서 보낼 수 있는데 단순히 패킷을 모아서 보내는 것이 어느때 좋냐?
*		- 헤더사이즈가 크지만 바디 데이터가 작을 때는 배보다 배꼽이 더 클 수 있다.. 그럴때 네이글을 on한다면 헤더 사이즈로인한 낭비를 줄일 수 있다 
* 
* 네이글을 끄면 패킷량이 늘어나지만 줄이는 방법은 ??
*	- 마우스 이벤트 줄이기 ..
*		- 마우스가 x, y축으로 움직일 때 샘플링레이트를 제한한다.
*		- 게임 내부 프레임에 맞춰서 초당 60번이나, 30번 
*	- 
*/

/*
* 
* [트리]
* 
* - 트리의 재귀적 속성 및 서브트리 
*	- 큰 트리 내부에 작은 서브트리들이 존재한다. 
* 
* - Root노드 왜 루트인가? 뒤집어 봤을 때 root가 그림상 정말로 뿌리 처럼 생김. 
* 
* - depth.. 아래로 갈 수록 root 0, 1, 2, 3..
* 
* 
*/